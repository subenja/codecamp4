const { main } = require('./main');

describe("ให้อาร์เรย์ของตัวอักษร R, G และ B ให้แยกค่าที่อยู่ในอาร์เรย์ดังกล่าวมาจัดเรียงใหม่โดยที่ตัว R ทั้งหมดต้องมาก่อน G ทั้งหมดมาเป็นอันดับสอง และ B ทั้งหมดมาเป็นตัวสุดท้าย", () => {
  test("ให้อาร์เรย์ ['G', 'B', 'R', 'R', 'B', 'R', 'G'] ควรคืนค่า ['R', 'R', 'R', 'G', 'G', 'B', 'B']", () => {
  	expect(main(['G', 'B', 'R', 'R', 'B', 'R', 'G'])).toEqual(['R', 'R', 'R', 'G', 'G', 'B', 'B'])
	});
	test("ให้อาร์เรย์ [ 'G', 'B', 'G', 'G' ] ควรคืนค่า ['G', 'G', 'G', 'B']", () => {
		expect(main([ 'G', 'B', 'G', 'G' ])).toEqual(['G', 'G', 'G', 'B'])
	});
	test("ให้อาร์เรย์ [ 'G', 'R', 'B', 'R', 'G', 'G' ] ควรคืนค่า ['R', 'R', 'G', 'G', 'G', 'B']", () => {
		expect(main([ 'G', 'R', 'B', 'R', 'G', 'G' ])).toEqual(['R', 'R', 'G', 'G', 'G', 'B'])
	});
	test("ให้อาร์เรย์ [ 'B', 'R' ] ควรคืนค่า ['R', 'B']", () => {
		expect(main([ 'B', 'R' ])).toEqual(['R', 'B'])
	});
	test("ให้อาร์เรย์ [ 'G', 'G' ] ควรคืนค่า [ 'G', 'G' ]", () => {
		expect(main([ 'G', 'G' ])).toEqual([ 'G', 'G' ])
	});
	test("ให้อาร์เรย์ ['G', 'G', 'G', 'B', 'R', 'B', 'B'] ควรคืนค่า ['R', 'G', 'G', 'G', 'B', 'B', 'B']", () => {
		expect(main(['G', 'G', 'G', 'B', 'R', 'B', 'B'])).toEqual(['R', 'G', 'G', 'G', 'B', 'B', 'B'])
	});
	test("ให้อาร์เรย์ ['G', 'R', 'G', 'R', 'B', 'R', 'G', 'G'] ควรคืนค่า ['R', 'R', 'R', 'G', 'G', 'G', 'G', 'B']", () => {
		expect(main(['G', 'R', 'G', 'R', 'B', 'R', 'G', 'G'])).toEqual(['R', 'R', 'R', 'G', 'G', 'G', 'G', 'B'])
	});
	test("ให้อาร์เรย์ [ 'R', 'B', 'G' ] ควรคืนค่า ['R', 'G', 'B']]", () => {
		expect(main(['G', 'R', 'G', 'R', 'B', 'R', 'G', 'G'])).toEqual(['R', 'R', 'R', 'G', 'G', 'G', 'G', 'B'])
	});
	test("ให้อาร์เรย์ [ 'B', 'G' ] ควรคืนค่า ['G', 'B']", () => {
		expect(main([ 'B', 'G' ])).toEqual(['G', 'B'])
	});
	test("ให้อาร์เรย์ [ 'R', 'B', 'B', 'B', 'B', 'R' ] ควรคืนค่า ['R', 'R', 'B', 'B', 'B', 'B']", () => {
		expect(main([ 'R', 'B', 'B', 'B', 'B', 'R' ])).toEqual(['R', 'R', 'B', 'B', 'B', 'B'])
	});
});
